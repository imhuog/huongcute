<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C·ªù L·∫≠t Online - Enhanced Multiplayer Othello</title>
    <style>
        :root {
            /* Default Theme */
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: rgba(255, 255, 255, 0.1);
            --text-primary: white;
            --text-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #FFD700;
            --success-color: #00ff88;
            --error-color: #ff6b6b;
            --board-bg: #2d3748;
            --cell-bg: #4a5568;
            --cell-hover: #718096;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            --bg-secondary: rgba(0, 0, 0, 0.3);
            --text-primary: #ecf0f1;
            --text-secondary: #bdc3c7;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --error-color: #e74c3c;
            --board-bg: #1a1a1a;
            --cell-bg: #2c2c2c;
            --cell-hover: #3c3c3c;
        }

        /* Neon Theme */
        [data-theme="neon"] {
            --bg-primary: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
            --bg-secondary: rgba(16, 213, 194, 0.1);
            --text-primary: #00ff88;
            --text-secondary: #10d5c2;
            --accent-color: #ff0080;
            --success-color: #00ff88;
            --error-color: #ff0040;
            --board-bg: #000;
            --cell-bg: #1a1a2e;
            --cell-hover: #16213e;
        }

        /* Nature Theme */
        [data-theme="nature"] {
            --bg-primary: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            --bg-secondary: rgba(255, 255, 255, 0.2);
            --text-primary: #2d5016;
            --text-secondary: #3e6b1f;
            --accent-color: #ff6b35;
            --success-color: #4caf50;
            --error-color: #f44336;
            --board-bg: #6b5b54;
            --cell-bg: #8b7355;
            --cell-hover: #a0845c;
        }

        /* Ocean Theme */
        [data-theme="ocean"] {
            --bg-primary: linear-gradient(135deg, #667db6 0%, #0082c8 100%);
            --bg-secondary: rgba(255, 255, 255, 0.15);
            --text-primary: white;
            --text-secondary: #e1f5fe;
            --accent-color: #ffd54f;
            --success-color: #26c6da;
            --error-color: #ef5350;
            --board-bg: #1565c0;
            --cell-bg: #1976d2;
            --cell-hover: #1e88e5;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--accent-color), var(--success-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            color: var(--text-secondary);
        }

        /* Toast Notification */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            border-left: 4px solid var(--accent-color);
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.success {
            border-left-color: var(--success-color);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.15), rgba(0, 0, 0, 0.9));
        }

        .toast.error {
            border-left-color: var(--error-color);
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.15), rgba(0, 0, 0, 0.9));
        }

        .toast.warning {
            border-left-color: #ffa726;
            background: linear-gradient(135deg, rgba(255, 167, 38, 0.15), rgba(0, 0, 0, 0.9));
        }

        .toast.info {
            border-left-color: #42a5f5;
            background: linear-gradient(135deg, rgba(66, 165, 245, 0.15), rgba(0, 0, 0, 0.9));
        }

        .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .toast-close {
            margin-left: auto;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Menu screens */
        .screen {
            display: none;
            width: 100%;
            max-width: 500px;
            text-align: center;
        }

        .screen.active {
            display: block;
        }

        .menu-card {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .input-group {
            margin: 20px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 5px;
            min-width: 150px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #feca57, #ff9ff3);
            color: white;
        }

        .btn-ai {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            min-width: 100px;
        }

        /* Room info */
        .room-info {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid var(--success-color);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .room-id {
            font-size: 2rem;
            font-weight: bold;
            color: var(--success-color);
            margin-bottom: 10px;
        }

        .share-link {
            font-size: 0.9rem;
            word-break: break-all;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }

        /* Game interface */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 100%;
        }

        .top-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }

        .top-section.local-mode {
            flex-direction: column;
            align-items: center;
        }

        .players-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-card {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            min-width: 200px;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .player-card.active {
            border-color: var(--success-color);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            transform: scale(1.05);
        }

        .player-card.offline {
            opacity: 0.6;
            border-color: var(--error-color);
        }

        .player-card.ai {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
        }

        .player-name {
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .emoji-selector {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .emoji-option {
            font-size: 1.5rem;
            padding: 5px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .emoji-option:hover {
            transform: scale(1.2);
            background: var(--bg-secondary);
        }

        .emoji-option.selected {
            border-color: var(--accent-color);
            background: rgba(255, 215, 0, 0.3);
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        /* Chat section */
        .chat-section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 15px;
            width: 300px;
            height: 400px;
            display: flex;
            flex-direction: column;
        }

        .chat-section.bottom {
            width: 100%;
            max-width: 600px;
            height: 200px;
            margin-top: 20px;
        }

        .chat-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-primary);
            text-align: center;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            background: rgba(0,0,0,0.1);
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            background: var(--bg-secondary);
            font-size: 0.9rem;
        }

        .chat-sender {
            font-weight: bold;
            color: var(--accent-color);
        }

        .chat-input-container {
            display: flex;
            gap: 5px;
        }

        .chat-input {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 15px;
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .chat-send {
            padding: 8px 12px;
            border: none;
            border-radius: 50%;
            background: var(--success-color);
            color: white;
            cursor: pointer;
        }

        /* Stats and leaderboard */
        .stats-section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 15px;
            width: 300px;
            height: 400px;
            overflow-y: auto;
        }

        .stats-header {
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--text-primary);
            text-align: center;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0,0,0,0.1);
            border-radius: 5px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }

        .leaderboard-rank {
            font-weight: bold;
            color: var(--accent-color);
        }

        .leaderboard-name {
            flex: 1;
            margin: 0 10px;
        }

        .leaderboard-rating {
            font-weight: bold;
            color: var(--success-color);
        }

        /* Theme selector */
        .theme-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .theme-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .theme-option:hover {
            transform: scale(1.1);
        }

        .theme-option.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .theme-default { background: linear-gradient(135deg, #667eea, #764ba2); }
        .theme-dark { background: linear-gradient(135deg, #2c3e50, #34495e); }
        .theme-neon { background: linear-gradient(135deg, #0f0f0f, #1a1a2e); }
        .theme-nature { background: linear-gradient(135deg, #56ab2f, #a8e6cf); }
        .theme-ocean { background: linear-gradient(135deg, #667db6, #0082c8); }

        .board-container {
            position: relative;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            background: var(--board-bg);
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 40px;
            height: 40px;
            background: var(--cell-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .cell:hover {
            background: var(--cell-hover);
            transform: scale(1.05);
        }

        .cell.valid-move {
            border: 2px solid var(--success-color);
            animation: sparkle 1s infinite;
            background: rgba(0, 255, 136, 0.2);
        }

        .cell.valid-move:hover {
            background: rgba(0, 255, 136, 0.4);
        }

        @keyframes sparkle {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.8); }
        }

        .piece {
            font-size: 1.8rem;
            animation: placepiece 0.3s ease-out;
            transition: transform 0.3s ease;
        }

        .piece.flipping {
            animation: flip 0.6s ease-in-out;
        }

        @keyframes placepiece {
            0% { transform: scale(0) rotate(180deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        @keyframes flip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }

        .turn-indicator {
            text-align: center;
            font-size: 1.3rem;
            margin-bottom: 20px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .connection-status.connected {
            background: var(--success-color);
            color: white;
        }

        .connection-status.disconnected {
            background: var(--error-color);
            color: white;
        }

        .connection-status.connecting {
            background: var(--accent-color);
            color: white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .game-over-content {
            text-align: center;
            color: white;
            animation: bounceIn 0.8s ease-out;
        }

        .winner-announcement {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--accent-color), var(--success-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .final-score {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* AI thinking indicator */
        .ai-thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .tab {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .tab.active {
            background: var(--accent-color);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .title { font-size: 2rem; }
            .top-section { flex-direction: column; }
            .players-section { flex-direction: column; align-items: center; }
            .player-card, .chat-section, .stats-section { min-width: 280px; width: 100%; max-width: 350px; }
            .cell { width: 35px; height: 35px; }
            .piece { font-size: 1.5rem; }
            .btn { width: 200px; margin: 5px 0; }
            .toast { min-width: 250px; font-size: 0.9rem; }
            .toast-container { right: 10px; top: 10px; }
        }

        @media (max-width: 480px) {
            .cell { width: 30px; height: 30px; }
            .piece { font-size: 1.2rem; }
            .board { padding: 5px; }
        }
    </style>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body data-theme="default">
    <div class="header">
        <h1 class="title">üåê C·ªù L·∫≠t Online Enhanced</h1>
        <p class="subtitle">AI ‚Ä¢ Chat ‚Ä¢ Leaderboard ‚Ä¢ Stats ‚Ä¢ Themes</p>
    </div>

    <div class="connection-status" id="connection-status">
        üîÑ ƒêang k·∫øt n·ªëi...
    </div>

    <div class="toast-container" id="toast-container"></div>

    <div class="screen active" id="main-menu">
        <div class="menu-card">
            <h2>üì± Ch√†o m·ª´ng ƒë·∫øn v·ªõi C·ªù L·∫≠t Online Enhanced!</h2>
            <p>Ch∆°i c·ªù l·∫≠t v·ªõi b·∫°n b√®, AI, v√† nhi·ªÅu t√≠nh nƒÉng m·ªõi</p>
            <div class="input-group">
                <label for="player-name">üë§ T√™n c·ªßa b·∫°n:</label>
                <input type="text" id="player-name" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..." maxlength="20">
            </div>
            <div class="theme-selector">
                <div class="theme-option theme-default selected" data-theme="default" title="Default"></div>
                <div class="theme-option theme-dark" data-theme="dark" title="Dark"></div>
                <div class="theme-option theme-neon" data-theme="neon" title="Neon"></div>
                <div class="theme-option theme-nature" data-theme="nature" title="Nature"></div>
                <div class="theme-option theme-ocean" data-theme="ocean" title="Ocean"></div>
            </div>
            <div style="margin: 30px 0;">
                <button class="btn btn-primary" onclick="game.createRoom('online')">
                    üè† T·∫°o Ph√≤ng Online
                </button>
                <button class="btn btn-secondary" onclick="game.showJoinRoom()">
                    üö™ V√†o Ph√≤ng
                </button>
            </div>
            <div style="margin: 20px 0;">
                <button class="btn btn-ai" onclick="game.showGameScreen('local-ai')">
                    ü§ñ Ch∆°i V·ªõi AI
                </button>
                <button class="btn btn-info" onclick="game.showRoomList()">
                    üåç Xem Ph√≤ng ƒêang Ho·∫°t ƒê·ªông
                </button>
            </div>
            <div style="margin: 20px 0;">
                <button class="btn btn-info" onclick="game.showLeaderboard()">
                    üèÜ B·∫£ng X·∫øp H·∫°ng
                </button>
                <button class="btn btn-info" onclick="game.showStats()">
                    üìä Th·ªëng K√™ C·ªßa T√¥i
                </button>
            </div>
        </div>
    </div>

    <div class="screen" id="join-room-screen">
        <div class="menu-card">
            <h2>üö™ Tham Gia Ph√≤ng</h2>
            <div class="input-group">
                <label for="room-id-input">üÜî ID Ph√≤ng:</label>
                <input type="text" id="room-id-input" placeholder="Nh·∫≠p ID ph√≤ng...">
            </div>
            <div class="input-group">
                <label for="player-name-join">üë§ T√™n c·ªßa b·∫°n:</label>
                <input type="text" id="player-name-join" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n...">
            </div>
            <button class="btn btn-primary" onclick="game.joinRoom()">üöÄ Tham Gia</button>
            <button class="btn btn-secondary" onclick="game.showMainMenu()">‚¨ÖÔ∏è Quay L·∫°i</button>
        </div>
    </div>

    <div class="screen" id="room-list-screen">
        <div class="menu-card">
            <h2>üåç Ph√≤ng ƒêang Ho·∫°t ƒê·ªông</h2>
            <div id="room-list" style="max-height: 300px; overflow-y: auto;">
                <p>ƒêang t·∫£i danh s√°ch ph√≤ng...</p>
            </div>
            <button class="btn btn-secondary" onclick="game.showMainMenu()" style="margin-top: 20px;">‚¨ÖÔ∏è Quay L·∫°i</button>
        </div>
    </div>

    <div class="screen" id="leaderboard-screen">
        <div class="menu-card">
            <h2>üèÜ B·∫£ng X·∫øp H·∫°ng</h2>
            <div id="leaderboard-list" style="max-height: 400px; overflow-y: auto;">
                <p>ƒêang t·∫£i b·∫£ng x·∫øp h·∫°ng...</p>
            </div>
            <button class="btn btn-secondary" onclick="game.showMainMenu()" style="margin-top: 20px;">‚¨ÖÔ∏è Quay L·∫°i</button>
        </div>
    </div>

    <div class="screen" id="stats-screen">
        <div class="menu-card">
            <h2>üìä Th·ªëng K√™ C·ªßa T√¥i</h2>
            <div id="stats-content" style="max-height: 400px; overflow-y: auto;">
                <p>ƒêang t·∫£i th·ªëng k√™...</p>
            </div>
            <button class="btn btn-secondary" onclick="game.showMainMenu()" style="margin-top: 20px;">‚¨ÖÔ∏è Quay L·∫°i</button>
        </div>
    </div>

    <div class="screen" id="room-info-screen">
        <div class="menu-card room-info">
            <h2>üè† Ph√≤ng C·ªßa B·∫°n</h2>
            <p>ID Ph√≤ng:</p>
            <p class="room-id" id="current-room-id"></p>
            <p>Link chia s·∫ª:</p>
            <p class="share-link" id="share-link"></p>
            <button class="btn btn-secondary btn-small" onclick="game.copyShareLink()">Sao ch√©p Link</button>
            <button class="btn btn-primary" onclick="game.startGame()">‚ñ∂Ô∏è B·∫Øt ƒê·∫ßu Game</button>
            <button class="btn btn-info" onclick="game.showGameScreen('online');">Chuy·ªÉn ƒë·∫øn game</button>
            <button class="btn btn-secondary" onclick="game.leaveRoom()">üëã R·ªùi Ph√≤ng</button>
        </div>
    </div>

    <div class="screen" id="game-screen">
        <div class="game-container">
            <div class="turn-indicator" id="turn-indicator"></div>
            <div class="top-section">
                <div class="players-section" id="players-section">
                    </div>
                <div class="chat-section">
                    <div class="chat-header">üí¨ Chat Trong Ph√≤ng</div>
                    <div class="chat-messages" id="chat-messages"></div>
                    <div class="chat-input-container">
                        <input type="text" id="chat-input" class="chat-input" placeholder="Nh·∫≠p tin nh·∫Øn...">
                        <button class="chat-send" onclick="game.sendChatMessage()">G·ª≠i</button>
                    </div>
                </div>
            </div>
            
            <div class="board-container">
                <div class="board" id="othello-board">
                    </div>
                <div class="ai-thinking" id="ai-thinking-indicator" style="display: none;">AI ƒëang nghƒ©...</div>
            </div>

            <div class="tabs">
                <button class="tab active" data-tab="chat">Chat</button>
                <button class="tab" data-tab="room-info">Th√¥ng tin ph√≤ng</button>
                <button class="tab" data-tab="local-actions">H√†nh ƒë·ªông offline</button>
            </div>
            
            <div class="tab-content active" id="tab-chat">
                <div class="chat-section bottom">
                    <div class="chat-header">üí¨ Chat Trong Ph√≤ng</div>
                    <div class="chat-messages" id="chat-messages-bottom"></div>
                    <div class="chat-input-container">
                        <input type="text" id="chat-input-bottom" class="chat-input" placeholder="Nh·∫≠p tin nh·∫Øn...">
                        <button class="chat-send" onclick="game.sendChatMessage()">G·ª≠i</button>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="tab-room-info">
                <div class="menu-card room-info">
                    <h2>üè† Th√¥ng tin Ph√≤ng</h2>
                    <p>ID Ph√≤ng:</p>
                    <p class="room-id" id="game-room-id"></p>
                    <p>Link chia s·∫ª:</p>
                    <p class="share-link" id="game-share-link"></p>
                    <button class="btn btn-secondary btn-small" onclick="game.copyShareLink()">Sao ch√©p Link</button>
                    <button class="btn btn-secondary" onclick="game.leaveRoom()">üëã R·ªùi Ph√≤ng</button>
                </div>
            </div>

            <div class="tab-content" id="tab-local-actions">
                <div class="menu-card">
                    <h2>Offline Actions</h2>
                    <button class="btn btn-primary" onclick="game.resetGame()">Ch∆°i L·∫°i (Local)</button>
                    <button class="btn btn-secondary" onclick="game.undoMove()">Undo (Local)</button>
                    <button class="btn btn-ai" onclick="game.toggleAI()">Toggle AI (Local)</button>
                </div>
            </div>

            <button class="btn btn-secondary" onclick="game.showMainMenu()" style="margin-top: 20px;">‚¨ÖÔ∏è Quay L·∫°i Menu</button>
        </div>
    </div>

    <div class="game-over" id="game-over-overlay">
        <div class="game-over-content">
            <h2 class="winner-announcement" id="winner-announcement"></h2>
            <p class="final-score" id="final-score"></p>
            <button class="btn btn-primary" onclick="game.resetGame()">Ch∆°i L·∫°i</button>
            <button class="btn btn-secondary" onclick="game.showMainMenu()">V·ªÅ Menu Ch√≠nh</button>
        </div>
    </div>

    <script>
        // Utility function for toast notifications
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${getToastIcon(type)}</span>
                <span>${message}</span>
                <button class="toast-close" onclick="this.parentElement.remove()">‚úñ</button>
            `;
            container.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('show');
            }, 10); // Small delay to trigger CSS transition

            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }

        function getToastIcon(type) {
            switch (type) {
                case 'success': return '‚úÖ';
                case 'error': return '‚ùå';
                case 'warning': return '‚ö†Ô∏è';
                case 'info': return '‚ÑπÔ∏è';
                default: return '';
            }
        }

        class EnhancedOthelloGame {
            constructor() {
                this.socket = null;
                this.playerName = localStorage.getItem('playerName') || '';
                this.roomId = null;
                this.roomName = null;
                this.isHost = false;
                this.playerColor = 0; // 1 for black, 2 for white, 0 for spectator/not in game
                this.currentBoard = [];
                this.currentScores = { 1: 0, 2: 0 };
                this.currentPlayerTurn = 0;
                this.onlinePlayers = []; // { id, name, color, connected }
                this.spectators = [];
                this.gameMode = 'online'; // 'online' or 'local-ai'
                this.gameStarted = false;
                this.gameOver = false;
                this.aiEnabled = false;
                this.moveHistory = []; // For local undo

                this.setupEventListeners();
                this.connectSocket();
                this.loadTheme();
                this.updatePlayerNameInput();
            }

            // Socket Connection and Handlers
            connectSocket() {
                if (this.socket && this.socket.connected) {
                    console.log('Socket already connected.');
                    return;
                }
                this.socket = io();
                document.getElementById('connection-status').className = 'connection-status connecting';
                document.getElementById('connection-status').textContent = 'üîÑ ƒêang k·∫øt n·ªëi...';

                this.socket.on('connect', () => {
                    console.log('Connected to server:', this.socket.id);
                    document.getElementById('connection-status').className = 'connection-status connected';
                    document.getElementById('connection-status').textContent = '‚úÖ ƒê√£ k·∫øt n·ªëi';
                    if (this.roomId) {
                        // Attempt to rejoin the room if coming back online
                        this.joinRoom(this.roomId);
                    }
                });

                this.socket.on('disconnect', () => {
                    console.log('Disconnected from server.');
                    document.getElementById('connection-status').className = 'connection-status disconnected';
                    document.getElementById('connection-status').textContent = '‚ùå M·∫•t k·∫øt n·ªëi';
                    showToast('M·∫•t k·∫øt n·ªëi v·ªõi m√°y ch·ªß. ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...', 'error', 0); // Show persistent error
                });

                this.socket.on('reconnect', (attemptNumber) => {
                    console.log(`Reconnected to server after ${attemptNumber} attempts.`);
                    document.getElementById('connection-status').className = 'connection-status connected';
                    document.getElementById('connection-status').textContent = '‚úÖ ƒê√£ k·∫øt n·ªëi';
                    showToast('ƒê√£ k·∫øt n·ªëi l·∫°i th√†nh c√¥ng!', 'success');
                    // Rejoin room if was in one
                    if (this.roomId && this.playerName) {
                         this.socket.emit('joinRoom', { roomId: this.roomId, playerName: this.playerName });
                    }
                });

                // Server Responses
                this.socket.on('updateRoomList', (rooms) => {
                    const roomListDiv = document.getElementById('room-list');
                    if (roomListDiv) {
                        roomListDiv.innerHTML = '';
                        if (rooms.length === 0) {
                            roomListDiv.innerHTML = '<p>Kh√¥ng c√≥ ph√≤ng n√†o ƒëang ho·∫°t ƒë·ªông.</p>';
                        } else {
                            rooms.forEach(room => {
                                const roomItem = document.createElement('div');
                                roomItem.className = 'menu-card';
                                roomItem.style.marginBottom = '10px';
                                roomItem.innerHTML = `
                                    <p><strong>ID:</strong> ${room.id} ${room.name !== room.id ? `(${room.name})` : ''}</p>
                                    <p><strong>Ch·ªß ph√≤ng:</strong> ${room.hostName}</p>
                                    <p><strong>Ng∆∞·ªùi ch∆°i:</strong> ${room.players}/${room.maxPlayers}</p>
                                    <button class="btn btn-info btn-small" onclick="game.autoFillJoinRoom('${room.id}')">Tham Gia</button>
                                `;
                                roomListDiv.appendChild(roomItem);
                            });
                        }
                    }
                });

                this.socket.on('roomCreated', (roomInfo) => {
                    this.roomId = roomInfo.roomId;
                    this.roomName = roomInfo.roomName;
                    this.isHost = roomInfo.isHost;
                    this.playerColor = roomInfo.playerColor;
                    this.onlinePlayers = roomInfo.players;
                    this.currentBoard = roomInfo.board;
                    this.currentScores = roomInfo.scores;
                    this.currentPlayerTurn = roomInfo.currentPlayer;
                    this.gameStarted = roomInfo.gameStarted;
                    this.spectators = roomInfo.spectators;
                    this.showRoomInfo(roomInfo);
                    showToast(`ƒê√£ t·∫°o ph√≤ng m·ªõi: ${this.roomId}`, 'success');
                });

                this.socket.on('joinedRoom', (roomInfo) => {
                    this.roomId = roomInfo.roomId;
                    this.roomName = roomInfo.roomName;
                    this.isHost = roomInfo.isHost;
                    this.playerColor = roomInfo.playerColor;
                    this.onlinePlayers = roomInfo.players;
                    this.currentBoard = roomInfo.board;
                    this.currentScores = roomInfo.scores;
                    this.currentPlayerTurn = roomInfo.currentPlayer;
                    this.gameStarted = roomInfo.gameStarted;
                    this.spectators = roomInfo.spectators;
                    this.showGameScreen('online');
                    this.renderBoard();
                    this.updatePlayerCards();
                    this.updateTurnIndicator();
                    if (this.gameStarted) {
                        showToast(`ƒê√£ tham gia ph√≤ng ${this.roomName}. Tr√≤ ch∆°i ƒëang di·ªÖn ra!`, 'info');
                    } else {
                        showToast(`ƒê√£ tham gia ph√≤ng ${this.roomName}. ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c...`, 'info');
                    }
                });

                this.socket.on('playerJoined', (data) => {
                    this.onlinePlayers = data.playersInRoom;
                    this.spectators = data.spectators;
                    this.updatePlayerCards();
                    showToast(`${data.name} ƒë√£ tham gia ph√≤ng!`, 'info');
                });

                this.socket.on('playerReconnected', (data) => {
                    this.onlinePlayers = data.playersInRoom;
                    this.spectators = data.spectators;
                    this.updatePlayerCards();
                    showToast(`${data.name} ƒë√£ k·∫øt n·ªëi l·∫°i ph√≤ng!`, 'info');
                });

                this.socket.on('spectatorJoined', (data) => {
                    this.spectators = data.spectators;
                    this.updatePlayerCards();
                    showToast(`${data.name} ƒë√£ v√†o ph√≤ng v·ªõi t∆∞ c√°ch kh√°n gi·∫£.`, 'info');
                });

                this.socket.on('playerDisconnected', (data) => {
                    this.onlinePlayers = data.playersInRoom;
                    this.spectators = data.spectators;
                    this.updatePlayerCards();
                    showToast(`${data.name} ƒë√£ r·ªùi/m·∫•t k·∫øt n·ªëi kh·ªèi ph√≤ng.`, 'warning');
                });

                this.socket.on('roomNotFound', (roomId) => {
                    showToast(`Kh√¥ng t√¨m th·∫•y ph√≤ng v·ªõi ID: ${roomId}`, 'error');
                    this.showMainMenu();
                });

                this.socket.on('roomFullAsSpectator', (roomInfo) => {
                    this.roomId = roomInfo.roomId;
                    this.roomName = roomInfo.roomName;
                    this.isHost = false; // Cannot be host if joining as spectator
                    this.playerColor = 0; // Spectator has no player color
                    this.onlinePlayers = roomInfo.players;
                    this.currentBoard = roomInfo.board;
                    this.currentScores = roomInfo.scores;
                    this.currentPlayerTurn = roomInfo.currentPlayer;
                    this.gameStarted = roomInfo.gameStarted;
                    this.spectators = roomInfo.spectators;
                    this.showGameScreen('online');
                    this.renderBoard();
                    this.updatePlayerCards();
                    this.updateTurnIndicator();
                    showToast(`Ph√≤ng ƒë√£ ƒë·∫ßy. B·∫°n ƒë√£ tham gia v·ªõi t∆∞ c√°ch kh√°n gi·∫£.`, 'warning');
                });

                this.socket.on('joinRoomError', (message) => {
                    showToast(`L·ªói khi tham gia ph√≤ng: ${message}`, 'error');
                    this.showMainMenu();
                });

                this.socket.on('gameStarted', (data) => {
                    this.gameStarted = true;
                    this.currentBoard = data.board;
                    this.currentPlayerTurn = data.currentPlayer;
                    this.onlinePlayers = data.players;
                    this.renderBoard();
                    this.updatePlayerCards();
                    this.updateTurnIndicator();
                    showToast('Tr√≤ ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu!', 'success');
                });

                this.socket.on('updateBoard', (data) => {
                    this.currentBoard = data.board;
                    this.currentScores = data.scores;
                    this.renderBoard(data.flippedPieces); // Pass flippedPieces for animation
                    this.updatePlayerCards(); // Update scores display
                });

                this.socket.on('switchTurn', (data) => {
                    this.currentPlayerTurn = data.currentPlayer;
                    this.updateTurnIndicator();
                });

                this.socket.on('noValidMoves', (data) => {
                    showToast(data.message, 'warning');
                });

                this.socket.on('gameOver', (data) => {
                    this.gameOver = true;
                    this.winner = data.winner; // 1 (black), 2 (white), 0 (tie)
                    this.currentScores = data.scores;
                    this.showGameOverScreen();
                    this.updatePlayerCards(); // Final score update
                });

                this.socket.on('chatMessage', (message) => {
                    this.addChatMessage(message.sender, message.message, message.timestamp);
                });

                this.socket.on('gameError', (message) => {
                    showToast(`L·ªói game: ${message}`, 'error');
                });

                this.socket.on('updateLeaderboard', (leaderboardData) => {
                    const leaderboardList = document.getElementById('leaderboard-list');
                    if (leaderboardList) {
                        leaderboardList.innerHTML = '';
                        if (leaderboardData.length === 0) {
                            leaderboardList.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu b·∫£ng x·∫øp h·∫°ng.</p>';
                        } else {
                            leaderboardData.forEach((entry, index) => {
                                const item = document.createElement('div');
                                item.className = 'leaderboard-item';
                                item.innerHTML = `
                                    <span class="leaderboard-rank">#${index + 1}</span>
                                    <span class="leaderboard-name">${entry.name}</span>
                                    <span class="leaderboard-rating">${entry.rating} Rating</span>
                                `;
                                leaderboardList.appendChild(item);
                            });
                        }
                    }
                });

                this.socket.on('updateStats', (statsData) => {
                    const statsContent = document.getElementById('stats-content');
                    if (statsContent) {
                        const myStats = statsData.find(s => s.name === this.playerName) || { 
                            name: this.playerName || 'B·∫°n', totalGames: 0, wins: 0, losses: 0, ties: 0, pointsScored: 0, pointsConceded: 0 
                        };
                        statsContent.innerHTML = `
                            <p class="stat-item"><span>T√™n:</span> <strong>${myStats.name}</strong></p>
                            <p class="stat-item"><span>T·ªïng s·ªë tr·∫≠n:</span> <strong>${myStats.totalGames}</strong></p>
                            <p class="stat-item"><span>Th·∫Øng:</span> <strong>${myStats.wins}</strong></p>
                            <p class="stat-item"><span>Thua:</span> <strong>${myStats.losses}</strong></p>
                            <p class="stat-item"><span>H√≤a:</span> <strong>${myStats.ties}</strong></p>
                            <p class="stat-item"><span>ƒêi·ªÉm ghi ƒë∆∞·ª£c:</span> <strong>${myStats.pointsScored}</strong></p>
                            <p class="stat-item"><span>ƒêi·ªÉm b·ªã th·ªßng:</span> <strong>${myStats.pointsConceded}</strong></p>
                        `;
                    }
                });

                this.socket.on('roomClosed', (message) => {
                    showToast(`Ph√≤ng ƒë√£ ƒë√≥ng: ${message}`, 'error');
                    this.roomId = null;
                    this.showMainMenu();
                });
            }

            // Screen Management
            showScreen(screenId) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                document.getElementById(screenId).classList.add('active');
            }

            showMainMenu() {
                this.showScreen('main-menu');
                this.gameMode = 'online'; // Reset mode when returning to main menu
                this.roomId = null;
                this.isHost = false;
                this.playerColor = 0;
                this.gameStarted = false;
                this.gameOver = false;
                this.onlinePlayers = [];
                this.spectators = [];
                document.getElementById('othello-board').innerHTML = ''; // Clear board
                document.getElementById('chat-messages').innerHTML = ''; // Clear chat
                document.getElementById('chat-messages-bottom').innerHTML = '';
                document.getElementById('ai-thinking-indicator').style.display = 'none';
            }

            showJoinRoom() {
                this.showScreen('join-room-screen');
                document.getElementById('player-name-join').value = this.playerName;
            }

            showRoomList() {
                this.showScreen('room-list-screen');
                this.socket.emit('requestRoomList');
            }

            showLeaderboard() {
                this.showScreen('leaderboard-screen');
                this.socket.emit('requestLeaderboard');
            }

            showStats() {
                this.showScreen('stats-screen');
                this.socket.emit('requestStats');
            }

            showRoomInfo(roomInfo) {
                document.getElementById('current-room-id').textContent = roomInfo.roomId;
                const shareLink = `${window.location.origin}?room=${roomInfo.roomId}`;
                document.getElementById('share-link').textContent = shareLink;
                this.showScreen('room-info-screen');
            }

            showGameScreen(mode) {
                this.gameMode = mode;
                this.showScreen('game-screen');
                if (this.gameMode === 'online') {
                    // Update room info for in-game tab
                    document.getElementById('game-room-id').textContent = this.roomId;
                    document.getElementById('game-share-link').textContent = `${window.location.origin}?room=${this.roomId}`;
                    // Show online specific elements, hide local specific elements
                    document.querySelector('.top-section').classList.remove('local-mode');
                    document.getElementById('tab-room-info').style.display = 'block';
                    document.getElementById('tab-local-actions').style.display = 'none';
                    // Activate chat tab by default
                    document.querySelector('.tabs .tab[data-tab="chat"]').click(); 
                } else { // local-ai mode
                    // Hide online specific elements, show local specific elements
                    document.querySelector('.top-section').classList.add('local-mode');
                    document.getElementById('tab-room-info').style.display = 'none';
                    document.getElementById('tab-local-actions').style.display = 'block';
                    // Activate local actions tab by default
                    document.querySelector('.tabs .tab[data-tab="local-actions"]').click(); 
                    this.initializeLocalGame();
                }
            }

            showGameOverScreen() {
                const winnerAnnouncement = document.getElementById('winner-announcement');
                const finalScore = document.getElementById('final-score');

                if (this.winner === 1) {
                    winnerAnnouncement.textContent = `BLACK (${this.onlinePlayers.find(p => p.color === 1)?.name || 'Player 1'}) TH·∫ÆNG!`;
                } else if (this.winner === 2) {
                    winnerAnnouncement.textContent = `WHITE (${this.onlinePlayers.find(p => p.color === 2)?.name || 'Player 2'}) TH·∫ÆNG!`;
                } else {
                    winnerAnnouncement.textContent = 'H√íA!';
                }
                finalScore.textContent = `Score: BLACK ${this.currentScores[1]} - ${this.currentScores[2]} WHITE`;
                document.getElementById('game-over-overlay').style.display = 'flex';
            }

            hideGameOverScreen() {
                document.getElementById('game-over-overlay').style.display = 'none';
            }

            // Player Name and Theme
            updatePlayerNameInput() {
                document.getElementById('player-name').value = this.playerName;
                document.getElementById('player-name-join').value = this.playerName;
            }

            savePlayerName() {
                this.playerName = document.getElementById('player-name').value.trim();
                localStorage.setItem('playerName', this.playerName);
                if (this.playerName === '') {
                    this.playerName = 'Guest';
                    localStorage.setItem('playerName', 'Guest');
                }
                showToast(`T√™n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c l∆∞u: ${this.playerName}`, 'success');
            }

            loadTheme() {
                const savedTheme = localStorage.getItem('theme') || 'default';
                document.body.setAttribute('data-theme', savedTheme);
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.theme === savedTheme) {
                        option.classList.add('selected');
                    }
                });
            }

            setTheme(themeName) {
                document.body.setAttribute('data-theme', themeName);
                localStorage.setItem('theme', themeName);
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.theme === themeName) {
                        option.classList.add('selected');
                    }
                });
            }

            // Room and Game Actions
            createRoom(mode) {
                this.savePlayerName();
                if (!this.playerName || this.playerName === 'Guest') {
                    showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n tr∆∞·ªõc khi t·∫°o ph√≤ng!', 'error');
                    return;
                }
                this.gameMode = mode;
                if (mode === 'online') {
                    this.socket.emit('createRoom', { playerName: this.playerName, gameMode: 'online', roomName: 'Ph√≤ng c·ªßa ' + this.playerName });
                } else {
                    this.showGameScreen('local-ai');
                    showToast('ƒêang ch∆°i v·ªõi AI!', 'info');
                }
            }

            joinRoom() {
                this.savePlayerName();
                const roomIdInput = document.getElementById('room-id-input').value.trim();
                const playerNameInput = document.getElementById('player-name-join').value.trim();

                if (!playerNameInput) {
                    showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n ƒë·ªÉ tham gia ph√≤ng!', 'error');
                    return;
                }
                if (!roomIdInput) {
                    showToast('Vui l√≤ng nh·∫≠p ID ph√≤ng ƒë·ªÉ tham gia!', 'error');
                    return;
                }
                this.playerName = playerNameInput; // Ensure current playerName is updated
                localStorage.setItem('playerName', this.playerName);

                this.socket.emit('joinRoom', { roomId: roomIdInput, playerName: this.playerName });
            }

            autoFillJoinRoom(roomId) {
                document.getElementById('room-id-input').value = roomId;
                this.showJoinRoom();
            }

            leaveRoom() {
                if (this.socket && this.roomId) {
                    this.socket.emit('disconnect'); // This will trigger server-side disconnect logic
                    this.showMainMenu();
                    showToast('ƒê√£ r·ªùi ph√≤ng.', 'info');
                }
            }

            startGame() {
                if (this.isHost && this.roomId) {
                    this.socket.emit('startGame', { roomId: this.roomId });
                } else if (this.roomId) {
                    showToast('Ch·ªâ ch·ªß ph√≤ng m·ªõi c√≥ th·ªÉ b·∫Øt ƒë·∫ßu game.', 'warning');
                } else {
                    showToast('Kh√¥ng c√≥ ph√≤ng ƒë·ªÉ b·∫Øt ƒë·∫ßu game.', 'error');
                }
            }

            // Game Board Rendering
            renderBoard(flippedPieces = []) {
                const boardDiv = document.getElementById('othello-board');
                if (!boardDiv) return;

                boardDiv.innerHTML = ''; // Clear existing board
                const pieceEmojis = { 1: '‚ö´', 2: '‚ö™' }; // Black, White

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        const piece = this.currentBoard[r][c];
                        if (piece !== 0) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.className = 'piece';
                            pieceSpan.textContent = pieceEmojis[piece];
                            // Add flipping class if this piece was flipped in the last move
                            if (flippedPieces.some(fp => fp.r === r && fp.c === c)) {
                                pieceSpan.classList.add('flipping');
                            }
                            cell.appendChild(pieceSpan);
                        }

                        // Add click listener for moves if it's the player's turn and online mode
                        if (this.gameMode === 'online' && this.playerColor === this.currentPlayerTurn && !this.gameOver) {
                            cell.addEventListener('click', () => this.makeMove(r, c));
                        } else if (this.gameMode === 'local-ai' && !this.gameOver) {
                             cell.addEventListener('click', () => this.makeLocalMove(r, c));
                        }
                        boardDiv.appendChild(cell);
                    }
                }
                this.updateValidMovesHighlight();
            }

            updateTurnIndicator() {
                const indicator = document.getElementById('turn-indicator');
                if (indicator) {
                    const playerNames = this.onlinePlayers.reduce((acc, p) => {
                        acc[p.color] = p.name;
                        return acc;
                    }, {});

                    if (this.gameMode === 'online') {
                         const currentPlayerName = playerNames[this.currentPlayerTurn] || 'Unknown';
                         if (this.playerColor === this.currentPlayerTurn) {
                            indicator.textContent = `ƒê·∫æN L∆Ø·ª¢T C·ª¶A B·∫†N (${currentPlayerName} - ${this.currentPlayerTurn === 1 ? 'ƒêen' : 'Tr·∫Øng'})`;
                            indicator.style.color = 'var(--accent-color)';
                         } else {
                            indicator.textContent = `ƒê·∫æN L∆Ø·ª¢T C·ª¶A ${currentPlayerName} (${this.currentPlayerTurn === 1 ? 'ƒêen' : 'Tr·∫Øng'})`;
                            indicator.style.color = 'var(--text-primary)';
                         }
                    } else { // local-ai
                        indicator.textContent = `L∆Ø·ª¢T: ${this.currentPlayerTurn === 1 ? 'ƒêen' : 'Tr·∫Øng'}`;
                        indicator.style.color = 'var(--accent-color)';
                    }
                }
            }

            updatePlayerCards() {
                const playersSection = document.getElementById('players-section');
                playersSection.innerHTML = '';
                const pieceEmojis = { 1: '‚ö´', 2: '‚ö™' }; // Black, White

                if (this.gameMode === 'online') {
                    this.onlinePlayers.forEach(p => {
                        const playerCard = document.createElement('div');
                        playerCard.className = `player-card ${p.color === this.currentPlayerTurn ? 'active' : ''} ${p.connected ? '' : 'offline'}`;
                        playerCard.innerHTML = `
                            <p class="player-name">${pieceEmojis[p.color]} ${p.name} ${p.isHost ? '(Ch·ªß)' : ''} ${!p.connected ? '(M·∫•t k·∫øt n·ªëi)' : ''}</p>
                            <p class="score">ƒêi·ªÉm: ${this.currentScores[p.color]}</p>
                        `;
                        playersSection.appendChild(playerCard);
                    });
                    this.spectators.forEach(s => {
                        const spectatorCard = document.createElement('div');
                        spectatorCard.className = 'player-card'; // No active/offline status for spectator
                        spectatorCard.innerHTML = `
                            <p class="player-name">üëÄ ${s.name} (Kh√°n gi·∫£)</p>
                            <p class="score"></p>
                        `;
                        playersSection.appendChild(spectatorCard);
                    });
                } else { // local-ai
                    const player1Name = this.playerName || 'Ng∆∞·ªùi ch∆°i 1';
                    const player2Name = this.aiEnabled ? 'AI' : 'Ng∆∞·ªùi ch∆°i 2';

                    const player1Card = document.createElement('div');
                    player1Card.className = `player-card ${1 === this.currentPlayerTurn ? 'active' : ''}`;
                    player1Card.innerHTML = `
                        <p class="player-name">‚ö´ ${player1Name}</p>
                        <p class="score">ƒêi·ªÉm: ${this.currentScores[1]}</p>
                    `;
                    playersSection.appendChild(player1Card);

                    const player2Card = document.createElement('div');
                    player2Card.className = `player-card ${2 === this.currentPlayerTurn ? 'active' : ''} ${this.aiEnabled ? 'ai' : ''}`;
                    player2Card.innerHTML = `
                        <p class="player-name">‚ö™ ${player2Name}</p>
                        <p class="score">ƒêi·ªÉm: ${this.currentScores[2]}</p>
                    `;
                    playersSection.appendChild(player2Card);
                }
            }

            updateValidMovesHighlight() {
                // Remove all previous highlights
                document.querySelectorAll('.cell.valid-move').forEach(cell => {
                    cell.classList.remove('valid-move');
                });

                if (this.gameMode === 'online' && this.playerColor === this.currentPlayerTurn && !this.gameOver) {
                    const validMoves = this.getValidMoves(this.currentBoard, this.playerColor);
                    validMoves.forEach(move => {
                        const cell = document.querySelector(`.cell[data-row="${move.r}"][data-col="${move.c}"]`);
                        if (cell) cell.classList.add('valid-move');
                    });
                } else if (this.gameMode === 'local-ai' && !this.gameOver) {
                     const validMoves = this.getValidMoves(this.currentBoard, this.currentPlayerTurn);
                    validMoves.forEach(move => {
                        const cell = document.querySelector(`.cell[data-row="${move.r}"][data-col="${move.c}"]`);
                        if (cell) cell.classList.add('valid-move');
                    });
                }
            }

            // Othello Game Logic (Client-side simulation for local mode and validation)
            getValidMoves(board, playerColor) {
                const validMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === 0 && this.isValidMove(board, r, c, playerColor)) {
                            validMoves.push({ r, c });
                        }
                    }
                }
                return validMoves;
            }

            isValidMove(board, r, c, playerColor) {
                if (board[r][c] !== 0) return false;

                const opponentColor = playerColor === 1 ? 2 : 1;
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1], // Horizontal & Vertical
                    [-1, -1], [-1, 1], [1, -1], [1, 1] // Diagonals
                ];

                for (const [dr, dc] of directions) {
                    let foundOpponent = false;
                    let currentR = r + dr;
                    let currentC = c + dc;

                    while (currentR >= 0 && currentR < 8 && currentC >= 0 && currentC < 8) {
                        if (board[currentR][currentC] === opponentColor) {
                            foundOpponent = true;
                        } else if (board[currentR][currentC] === playerColor && foundOpponent) {
                            return true;
                        } else {
                            break;
                        }
                        currentR += dr;
                        currentC += dc;
                    }
                }
                return false;
            }

            applyMove(board, r, c, playerColor) {
                if (!this.isValidMove(board, r, c, playerColor)) {
                    return { success: false, reason: 'Invalid move' };
                }

                const newBoard = board.map(row => [...row]); // Deep copy
                const flippedPieces = [];
                newBoard[r][c] = playerColor;
                const opponentColor = playerColor === 1 ? 2 : 1;
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];

                for (const [dr, dc] of directions) {
                    let lineToFlip = [];
                    let currentR = r + dr;
                    let currentC = c + dc;

                    while (currentR >= 0 && currentR < 8 && currentC >= 0 && currentC < 8) {
                        if (newBoard[currentR][currentC] === opponentColor) {
                            lineToFlip.push({ r: currentR, c: currentC });
                        } else if (newBoard[currentR][currentC] === playerColor) {
                            for (const { r: flipR, c: flipC } of lineToFlip) {
                                newBoard[flipR][flipC] = playerColor;
                                flippedPieces.push({ r: flipR, c: flipC });
                            }
                            break;
                        } else {
                            break;
                        }
                        currentR += dr;
                        currentC += dc;
                    }
                }
                return { success: true, newBoard, flippedPieces };
            }

            calculateScores(board) {
                let blackCount = 0;
                let whiteCount = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === 1) blackCount++;
                        else if (board[r][c] === 2) whiteCount++;
                    }
                }
                return { 1: blackCount, 2: whiteCount };
            }

            checkLocalGameEnd() {
                const movesForBlack = this.getValidMoves(this.currentBoard, 1).length;
                const movesForWhite = this.getValidMoves(this.currentBoard, 2).length;

                if (movesForBlack === 0 && movesForWhite === 0) {
                    this.gameOver = true;
                    this.updateLocalWinner();
                    this.showGameOverScreen();
                    return true;
                }

                if (this.getValidMoves(this.currentBoard, this.currentPlayerTurn).length === 0) {
                    showToast(`Ng∆∞·ªùi ch∆°i ${this.currentPlayerTurn === 1 ? 'ƒêen' : 'Tr·∫Øng'} kh√¥ng c√≥ n∆∞·ªõc ƒëi. B·ªè qua l∆∞·ª£t.`, 'warning');
                    this.currentPlayerTurn = this.currentPlayerTurn === 1 ? 2 : 1; // Switch turn
                    this.updateTurnIndicator();
                    // If after switching, the new current player also has no moves, game ends
                    if (this.getValidMoves(this.currentBoard, this.currentPlayerTurn).length === 0) {
                        this.gameOver = true;
                        this.updateLocalWinner();
                        this.showGameOverScreen();
                        return true;
                    }
                }
                return false;
            }

            updateLocalWinner() {
                if (this.currentScores[1] > this.currentScores[2]) {
                    this.winner = 1;
                } else if (this.currentScores[2] > this.currentScores[1]) {
                    this.winner = 2;
                } else {
                    this.winner = 0; // Tie
                }
            }

            // AI Logic (simple)
            aiMakeMove() {
                const aiIndicator = document.getElementById('ai-thinking-indicator');
                aiIndicator.style.display = 'block';

                setTimeout(() => {
                    const validMoves = this.getValidMoves(this.currentBoard, this.currentPlayerTurn);
                    if (validMoves.length > 0) {
                        // Simple AI: choose a random valid move
                        const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                        this.makeLocalMove(move.r, move.c);
                    }
                    aiIndicator.style.display = 'none';
                }, 1000); // Simulate thinking time
            }

            // Local Game Management
            initializeLocalGame() {
                this.currentBoard = Array(8).fill(0).map(() => Array(8).fill(0));
                this.currentBoard[3][3] = 2; // White
                this.currentBoard[3][4] = 1; // Black
                this.currentBoard[4][3] = 1; // Black
                this.currentBoard[4][4] = 2; // White
                this.currentPlayerTurn = 1; // Black starts
                this.currentScores = this.calculateScores(this.currentBoard);
                this.gameStarted = true;
                this.gameOver = false;
                this.hideGameOverScreen();
                this.moveHistory = []; // Reset history

                this.renderBoard();
                this.updatePlayerCards();
                this.updateTurnIndicator();
                this.updateValidMovesHighlight();
            }

            makeLocalMove(r, c) {
                if (this.gameOver) {
                    showToast('Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c!', 'info');
                    return;
                }
                if (this.currentBoard[r][c] !== 0) {
                    showToast('√î n√†y ƒë√£ c√≥ qu√¢n c·ªù!', 'warning');
                    return;
                }
                
                const moveResult = this.applyMove(this.currentBoard, r, c, this.currentPlayerTurn);

                if (moveResult.success) {
                    this.moveHistory.push({ board: JSON.parse(JSON.stringify(this.currentBoard)), player: this.currentPlayerTurn }); // Save state
                    this.currentBoard = moveResult.newBoard;
                    this.currentScores = this.calculateScores(this.currentBoard);
                    this.renderBoard(moveResult.flippedPieces);
                    this.updatePlayerCards();

                    if (!this.checkLocalGameEnd()) {
                        this.currentPlayerTurn = this.currentPlayerTurn === 1 ? 2 : 1; // Switch turn
                        this.updateTurnIndicator();
                        this.updateValidMovesHighlight();
                        if (this.aiEnabled && this.currentPlayerTurn === 2 && !this.gameOver) { // If AI's turn
                            this.aiMakeMove();
                        }
                    }
                } else {
                    showToast(moveResult.reason, 'error');
                }
            }

            resetGame() {
                if (this.gameMode === 'online') {
                    // For online, a "reset" would typically be creating a new room or leaving the current one.
                    // Or, if the server supports it, a 'resetGame' event.
                    // For now, prompt to leave room.
                    showToast('Trong ch·∫ø ƒë·ªô Online, b·∫°n c√≥ th·ªÉ r·ªùi ph√≤ng v√† t·∫°o ph√≤ng m·ªõi ho·∫∑c ch·ªù ch·ªß ph√≤ng b·∫Øt ƒë·∫ßu l·∫°i game.', 'info');
                } else { // local-ai
                    this.initializeLocalGame();
                    showToast('Game Local ƒë√£ ƒë∆∞·ª£c reset!', 'success');
                }
            }

            undoMove() {
                if (this.gameMode === 'online') {
                    showToast('T√≠nh nƒÉng Undo kh√¥ng kh·∫£ d·ª•ng trong ch·∫ø ƒë·ªô Online.', 'warning');
                } else {
                    if (this.moveHistory.length > 0) {
                        const lastMove = this.moveHistory.pop();
                        this.currentBoard = JSON.parse(JSON.stringify(lastMove.board));
                        this.currentPlayerTurn = lastMove.player;
                        this.currentScores = this.calculateScores(this.currentBoard);
                        this.gameOver = false; // Allow continuing after undo
                        this.hideGameOverScreen();
                        this.renderBoard();
                        this.updatePlayerCards();
                        this.updateTurnIndicator();
                        this.updateValidMovesHighlight();
                        showToast('ƒê√£ ho√†n t√°c n∆∞·ªõc ƒëi cu·ªëi c√πng.', 'info');
                    } else {
                        showToast('Kh√¥ng c√≥ n∆∞·ªõc ƒëi n√†o ƒë·ªÉ ho√†n t√°c.', 'warning');
                    }
                }
            }

            toggleAI() {
                if (this.gameMode === 'online') {
                    showToast('AI ch·ªâ kh·∫£ d·ª•ng trong ch·∫ø ƒë·ªô ch∆°i Offline.', 'warning');
                    return;
                }
                this.aiEnabled = !this.aiEnabled;
                showToast(`AI ƒë√£ ${this.aiEnabled ? 'B·∫¨T' : 'T·∫ÆT'}`, 'info');
                this.updatePlayerCards();
                if (this.aiEnabled && this.currentPlayerTurn === 2 && !this.gameOver) {
                    this.aiMakeMove();
                }
            }

            // Chat Functionality
            addChatMessage(sender, message, timestamp) {
                const chatMessagesDiv = document.getElementById('chat-messages');
                const chatMessagesBottomDiv = document.getElementById('chat-messages-bottom');

                const createMessageElement = (senderName, msgText, time) => {
                    const messageElement = document.createElement('div');
                    messageElement.className = 'chat-message';
                    const date = new Date(time);
                    const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    messageElement.innerHTML = `<span class="chat-sender">${senderName} (${timeString}):</span> ${msgText}`;
                    return messageElement;
                };

                const msgElement1 = createMessageElement(sender, message, timestamp);
                chatMessagesDiv.appendChild(msgElement1);
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;

                const msgElement2 = createMessageElement(sender, message, timestamp);
                chatMessagesBottomDiv.appendChild(msgElement2);
                chatMessagesBottomDiv.scrollTop = chatMessagesBottomDiv.scrollHeight;
            }

            sendChatMessage() {
                const chatInput = document.getElementById('chat-input');
                const chatInputBottom = document.getElementById('chat-input-bottom');
                const message = chatInput.value.trim();

                if (message) {
                    if (this.gameMode === 'online' && this.roomId) {
                        this.socket.emit('chatMessage', { roomId: this.roomId, message: message });
                    } else {
                        // For local mode, just display locally
                        this.addChatMessage(this.playerName || 'B·∫°n', message, Date.now());
                    }
                    chatInput.value = '';
                    chatInputBottom.value = '';
                }
            }

            copyShareLink() {
                const shareLinkElement = document.getElementById('share-link') || document.getElementById('game-share-link');
                if (shareLinkElement) {
                    const link = shareLinkElement.textContent;
                    navigator.clipboard.writeText(link).then(() => {
                        showToast('ƒê√£ sao ch√©p li√™n k·∫øt ph√≤ng!', 'success');
                    }).catch(err => {
                        console.error('Could not copy text: ', err);
                        showToast('Kh√¥ng th·ªÉ sao ch√©p li√™n k·∫øt. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
                    });
                }
            }

            setupEventListeners() {
                // Player name input handling
                document.getElementById('player-name').addEventListener('change', () => this.savePlayerName());
                document.getElementById('player-name-join').addEventListener('change', () => this.savePlayerName());

                // Theme selector
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.addEventListener('click', () => {
                        this.setTheme(option.dataset.theme);
                    });
                });

                // Chat input Enter key
                document.getElementById('chat-input').addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        this.sendChatMessage();
                    }
                });
                document.getElementById('chat-input-bottom').addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        this.sendChatMessage();
                    }
                });

                // Tab switching for game screen
                document.querySelectorAll('.tabs .tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
                    });
                });
            }
        }

        let game; // Declare game globally

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            game = new EnhancedOthelloGame();
            
            // Handle URL parameters for joining rooms
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            if (roomId) {
                document.getElementById('room-id-input').value = roomId;
                const savedPlayerName = localStorage.getItem('playerName');
                if (savedPlayerName) {
                    document.getElementById('player-name').value = savedPlayerName;
                    game.playerName = savedPlayerName;
                }
                game.showJoinRoom();
                game.showToast(`S·∫µn s√†ng tham gia ph√≤ng ${roomId}. Nh·∫≠p t√™n v√† nh·∫•n "Tham Gia"!`, 'info');
            }
        });

        // Handle page visibility change (for potential re-connection)
        document.addEventListener('visibilitychange', () => {
            if (game && game.socket) {
                if (document.hidden) {
                    // Page hidden - potentially disconnect or go idle
                } else {
                    // Page visible - reconnect if needed
                    if (game.socket.disconnected) {
                        game.socket.connect();
                    }
                }
            }
        });
    </script>
</body>
</html>
